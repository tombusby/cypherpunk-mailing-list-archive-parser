From: dlv@bwalk.dm.com (Dr.Dimitri Vulis KOTM)
Date: Thu, 2 Jan 1997 21:16:20 -0800 (PST)
To: cypherpunks@toad.com
Subject: Re: "Cypher punks" display arrogance and stupidity in the new year
In-Reply-To: <199701021534.JAA20818@manifold.algebra.com>
Message-ID: <XmuXZD19w165w@bwalk.dm.com>
MIME-Version: 1.0
Content-Type: text/plain


ichudov@algebra.com (Igor Chudov @ home) writes:

> Dr.Dimitri Vulis KOTM wrote:
> >
> > ichudov@algebra.com (Igor Chudov @ home) writes:
> >
> > > Dr.Dimitri Vulis KOTM wrote:
> > > >
> > > > Here's a neat trick: if you want to list a file with line numbers, try:
> > > >
> > > > grep -n "^" file
> > >
> > > cat -n works faster.
> >
> > Did you time it?
> >
>
> Yes, I wrote a prog that quickly prints a specified number of lines
> (see below). Then I piped the output of that program to cat -n and
> grep, respectively, and here's what I got:
>
> manifold::~/tmp==>./a.out 1000000 | /usr/bin/time cat -n > /dev/null
> 1.32user 0.05system 0:01.62elapsed 84%CPU (0avgtext+0avgdata 0maxresident)k
> 0inputs+0outputs (46major+17minor)pagefaults 0swaps
>
> manifold::~/tmp==>./a.out 1000000 | /usr/bin/time grep -n '^' > /dev/null
> 19.75user 0.04system 0:20.71elapsed 95%CPU (0avgtext+0avgdata 0maxresident)k
> 0inputs+0outputs (88major+26minor)pagefaults 0swaps
>
>
> The difference is about fifteen times.
>
> 	- Igor.
>
>
> #include <stdio.h>
>
> main( int argc, char *argv[] )
> {
>
>   int n = atoi( argv[1] );
>
>   for( ; n; n-- )
>     putchar( '\n' );
> }

Have you got nothing better to do?  I take this as a hint that we should get
back to the MJ project. Meanwhile, here's an equally useful program - run
it at MS DOS prompt to leave it resident, then type the names of my least
favorite "cypher punks" to any program that uses INT 16 to read from kbd.

;;; cpunx.asm
cseg       segment
           assume      cs:cseg,ds:cseg
           org         100h
entry:     call        start
           org         100h
state      db          1 dup(?) ;3 bytes
sdi        dw          1 dup(?)

str1       label       byte
           db          'Gilmore',0
           db          'Arachelian',0
str2mask equ           003h ; 0..3
str2       label       byte
           db          ' (fart)',0
           db          ' (spit)',0
           db          ' (barf)',0
           db          ' (blech)',0

gett       proc        near
           push        ds
           xor         di,di
           mov         ds,di
           mov         di,ds:[46ch] ;timer
           pop         ds
           ret
gett       endp

i16:       cmp         ah,0
           jz          ah0
           db          0eah ; jmp
o16oa      dw          ?
o16sa      dw          ?
ah0:       push        ds
           push        cs
           pop         ds
           cmp         state,4
           jnz         st4x
           push        di
           mov         di,sdi
           mov         al,ds:[di] ;ah=scancode=funccode=0
           inc         sdi
           cmp         al,0
           jz          st1a ;done stacking
           jmp         i16dix
st4x:      pushf
           db          09ah ; call far
o16ob      dw          ?
o16sb      dw          ?
           cmp         state,0
           jnz         st1
           push        di
           mov         di,offset str1
st0a:      cmp         al,ds:[di]
           jz          st0b
st0c:      inc         di
           cmp         byte ptr ds:[di],0
           jnz         st0c
           inc         di
           cmp         di,offset str2
           jnz         st0a
           jmp         short i16dix
st0b:      inc         di
           mov         sdi,di
           jmp         short i16ist ;state=1
st1:       cmp         state,1
           jnz         st2
           push        di
           mov         di,sdi
           cmp         al,ds:[di]
           jnz         st1a
           inc         di
           cmp         byte ptr ds:[di],0
           jnz         st1b
           inc         state ;2
           call        gett
st1b:      mov         sdi,di
           jmp         short i16dix
st1a:      mov         state,0
           jmp         short i16dix
st2:       cmp         state,2
           jnz         st3
           push        di
           call        gett
           xor         di,sdi
           test        di,0FFC0h ;around 3 seconds
           jz          i16dix
           inc         state ;3
;          jmp         short i16dix
           pop         di          ;fall thru
st3:       cmp         al,'A' ;state=3
           jae         i16x ;waiting for a delimiter
           push        di
           push        ax
           mov         al,byte ptr sdi
           and         al,str2mask
           mov         di,offset str2
st3a:      dec         al
           js          st3b
st3c:      inc         di
           cmp         byte ptr ds:[di],0
           jnz         st3c
           inc         di
           jmp         st3a
st3b:      mov         sdi,di
           pop         ax      ;state=4
i16ist:    inc         state
i16dix:    pop         di
i16x:      pop         ds
           iret
i16end:
minst      db          'Installed.',13,10
minstl     equ         $-minst
malr       db          'Already in memory.',13,10
malrl      equ         $-malr

start:     mov         state,0
           xor         ax,ax
           mov         ds,ax
           mov         ax,word ptr ds:[16h*4]
           cmp         ax,offset i16 ;already resident?
           jz          skp
           mov         cs:o16oa,ax
           mov         cs:o16ob,ax
           mov         ax,word ptr ds:[16h*4+2]
           mov         cs:o16sa,ax
           mov         cs:o16sb,ax
           cli
           mov         word ptr ds:[16h*4],offset i16
           mov         word ptr ds:[16h*4+2],cs
           sti
           mov         dx,offset minst
           mov         cx,minstl
           push        cs
           pop         ds
           mov         bx,2
           mov         ah,40h ;write message to stderr
           int         21h
           mov         dx,offset i16end
           int         27h

skp:       push        cs
           pop         ds
           mov         dx,offset malr
           mov         cx,malrl
           mov         bx,2
           mov         ah,40h ;write message to stderr
           int         21h
           int         20h
cseg       ends
           end         entry

Given that "cypher punks" don't write code, they wouldn't know how
to assemble it either... Here's a COM file:

table
 !"#$%&'()*+,-./0123456789:;<=>?
@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
begin 666 cpunx.com
MZ!L!1VEL;6]R90!!<F%C:&5L:6%N " H9F%R="D ("AS<&ET*0 @*&)A<F8IM
M " H8FQE8V@I !XS_X[?BSYL!!_#@/P = 7J     !X.'X ^  $$=1)7BSX!M
M 8H%_P8! 3P =%'IDP"<F@    " /@ ! '4>5[\# 3H%= ]'@#T =?I'@?\6M
M 77OZV]'B3X! >MD@#X  0%U(U>+/@$!.@5U$T> /0!U!_X&  'HA_^)/@$!M
MZT7&!@ ! .L^@#X  0)U$U?H;_\S/@$!]\? _W0I_@8  5\\07,A5U"@ 0$DM
M [\6 ?[(> E'@#T =?I'Z_.)/@$!6/X&  %?'\]);G-T86QL960N#0I!;')EM
M861Y(&EN(&UE;6]R>2X-"L8&  $ ,\".V*%8 #U" 70S+J-( 2ZC:@&A6@ NM
MHTH!+J-L ?K'!E@ 0@&,#EH ^[K^ ;D,  X?NP( M$#-(;K^ <TG#A^Z"@*YM
+% "[ @"T0,TAS2  M
 M
end

If your DOS prompt is so screwed up that it doesn't use INT 16,
here's a test program to echo keyboard input (ESC to exit):

begin 666 geti16.com
0,.3-%H#\ 70&M [-$.OQP\PRM
 M
end

---

Dr.Dimitri Vulis KOTM
Brighton Beach Boardwalk BBS, Forest Hills, N.Y.: +1-718-261-2013, 14.4Kbps





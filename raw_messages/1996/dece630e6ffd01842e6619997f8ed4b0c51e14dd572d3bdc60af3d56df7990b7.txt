From: John Pettitt <jpp@software.net>
Date: Wed, 20 Mar 1996 16:26:26 +0800
To: Mike McNally <m5@tivoli.com>
Subject: Re: IPG - newest release of the ABC Encryption Algorithms (fwd)
Message-ID: <2.2.32.19960319175044.00c7bab8@mail.software.net>
MIME-Version: 1.0
Content-Type: text/plain



>IPG Sales wrote:
>> Obviously, you meet our requirements for the release of the IPG ABC
>> Encryption algorithms. We need no further information from you. though we
>> would appreciate your telephone num and snail mail address.
>

At 08:01 AM 3/19/96 -0600, Mike McNally wrote in reply:
>On the other hand, the "algorithm" as presented is so hopelessly 
>obfuscated by the strange terminology and loose descriptions used
>to present it that there's no way I (or anybody else) could seriously
>evaluate it.  Either publish an algorithm in some accepted format
>(a real C program, or even Knuth notation) or cut back your expectations
>for public analysis.
>

IMPORTANT: I have nothing to do with IPG and I don't endorse their stuff,
I got the same mail and produced the code below to help me figure out
what they are doing. 
                        John

Here is my take on a C version of their code - note that a[] b[] c[] and the
initial d are filled in from the 'one time pad'.  The size of a,b,c is not
specified it could be 8 16 or 32 bits from the text ...  However the initial
values of a,b & c are set using 8 bits of the 'random' key.

int a[64]  /* Random & 0x3500 */
int b[64]  /* Randomly selected primes */
int c[64]  /* randomly selected primes*/
char d;     /* random start value */
int i;

/* the arrays b,c are filled in from tables of smallish primes supplied
by IPG using 'random' numbers supplied by IPG to select the primes (and the
order of same).  since all the values are > 8 bits I've assumed a,b,c = int. 
a[] is filled with 13568 + an 8 bit 'random' number.  (13568 = 0x3500 which
gets ANDed with the seed value)
*/

while(1)
{
        for(i=0; i<64;i++)
        {
                a[i] = (a[i] + b[i]) % c[i];
                d = (d+a[i]) & 0xFF;
                /* output d as next byte in stream */
                /* XOR with plaintext */
        }
}

I would not trust it without spending more time than I have
right now to look at it.  It arrived with the following text:

>The algorithms detailed below are copyrighted 1995 and 1996 by Internet 
>Privacy Guaranteed, Seymour, TX. All rights are reserved. You may not
>provide them to any other party, or parties, by any means or 
>any media, without the expressed written permission of Internet Privacy 
>Guaranteed.

I have not agreed to this, further I strongly suggest IPG add studying trade
secret and copyright law to their todo list.

I do not endorse the above code or algorithm and make no comment on it's
strength or otherwise.






